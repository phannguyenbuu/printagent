from __future__ import annotations

import base64
import csv
import logging
import re
import signal
import threading
import time
from dataclasses import dataclass, asdict
from datetime import datetime, timezone
from html import unescape
from pathlib import Path
from typing import Any
from urllib.parse import urljoin

import requests

from app.services.api_client import APIClient, Printer


LOGGER = logging.getLogger(__name__)
ADDRESS_DEBUG_LOG_FILE = Path("storage/data/address_list_debug.log")


@dataclass(slots=True)
class AddressEntry:
    type: str
    registration_no: str
    name: str
    user_code: str
    date_last_used: str
    email_address: str
    folder: str
    entry_id: str = ""


class RicohService:
    def __init__(self, api_client: APIClient, interval_seconds: int = 60) -> None:
        self.api_client = api_client
        self.interval_seconds = interval_seconds
        self._stop_event = threading.Event()
        self._thread: threading.Thread | None = None
        # Keep a monotonic local hint so address registration_no generated by app always increases.
        self._address_index_hint_by_ip: dict[str, int] = {}

    def start(self) -> None:
        if self._thread and self._thread.is_alive():
            LOGGER.info("Ricoh service is already running")
            return
        self._stop_event.clear()
        self._thread = threading.Thread(target=self._run_loop, daemon=True)
        self._thread.start()
        LOGGER.info("Ricoh service started. Interval: %ss", self.interval_seconds)

    def stop(self) -> None:
        self._stop_event.set()
        if self._thread:
            self._thread.join(timeout=3)
        LOGGER.info("Ricoh service stopped")

    def _run_loop(self) -> None:
        self.process_printers()
        while not self._stop_event.wait(self.interval_seconds):
            self.process_printers()

    def process_printers(self) -> None:
        printers = self.api_client.get_printers()
        for printer in printers:
            if printer.printer_type.lower() != "ricoh":
                continue
            try:
                html = self.read_counter(printer)
                payload = {
                    "printer_name": printer.name,
                    "ip": printer.ip,
                    "html": html,
                    "timestamp": self._timestamp(),
                }
                self.api_client.post_data(payload)
                LOGGER.info("Posted counter data for %s (%s)", printer.name, printer.ip)
            except Exception as exc:  # noqa: BLE001
                LOGGER.exception("Failed processing printer %s (%s): %s", printer.name, printer.ip, exc)

    @staticmethod
    def _timestamp() -> str:
        return datetime.now(timezone.utc).isoformat()

    @staticmethod
    def _append_address_debug(message: str) -> None:
        try:
            ADDRESS_DEBUG_LOG_FILE.parent.mkdir(parents=True, exist_ok=True)
            ts = datetime.now(timezone.utc).isoformat()
            with ADDRESS_DEBUG_LOG_FILE.open("a", encoding="utf-8") as fp:
                fp.write(f"[{ts}] {message}\n")
            LOGGER.info("address_debug %s", message)
        except Exception:  # noqa: BLE001
            return

    @staticmethod
    def _http_get(url: str, timeout: int = 10, session: requests.Session | None = None) -> str:
        client = session or requests.Session()
        response = client.get(url, timeout=timeout)
        response.raise_for_status()
        return response.text

    def read_counter(self, printer: Printer) -> str:
        return self._http_get(f"http://{printer.ip}/web/guest/en/websys/status/getUnificationCounter.cgi")

    def read_device_info(self, printer: Printer) -> str:
        return self._http_get(f"http://{printer.ip}/web/guest/en/websys/status/configuration.cgi")

    def read_status(self, printer: Printer) -> str:
        return self._http_get(f"http://{printer.ip}/web/guest/en/websys/webArch/getStatus.cgi")

    def read_network_interface(self, printer: Printer) -> str:
        session = self.create_http_client_auth_form_only(printer)
        target = "/web/entry/en/websys/netw/getInterface.cgi"
        try:
            return self.authenticate_and_get(session, printer, target)
        except Exception:  # noqa: BLE001
            return self._http_get(f"http://{printer.ip}/web/guest/en/websys/netw/getInterface.cgi", session=session)

    def process_device_info(self, printer: Printer, should_post: bool) -> dict[str, Any]:
        html = self.read_device_info(printer)
        payload = {
            "printer_name": printer.name,
            "ip": printer.ip,
            "html": html,
            "device_info": self.parse_device_info(html),
            "timestamp": self._timestamp(),
        }
        if should_post:
            self.api_client.post_data(payload)
        return payload

    def process_status(self, printer: Printer, should_post: bool) -> dict[str, Any]:
        try:
            html = self.read_status(printer)
            payload = {
                "printer_name": printer.name,
                "ip": printer.ip,
                "html": html,
                "status_data": self.parse_status(html),
                "timestamp": self._timestamp(),
            }
            if should_post:
                self.api_client.post_data(payload)
            return payload
        finally:
            self._logout_after_collect(printer, source="status")

    def process_counter(self, printer: Printer, should_post: bool) -> dict[str, Any]:
        try:
            html = self.read_counter(printer)
            payload = {
                "printer_name": printer.name,
                "ip": printer.ip,
                "html": html,
                "counter_data": self.parse_counter(html),
                "timestamp": self._timestamp(),
            }
            if should_post:
                self.api_client.post_data(payload)
            return payload
        finally:
            self._logout_after_collect(printer, source="counter")

    def _logout_after_collect(self, printer: Printer, source: str = "") -> None:
        # Best-effort cleanup requested by user flow: logout/reset right after each counter/status collect.
        try:
            self.reset_web_session(printer)
            LOGGER.info(
                "Logout after %s collect: name=%s ip=%s ok=true",
                source or "unknown",
                printer.name,
                printer.ip,
            )
        except Exception as exc:  # noqa: BLE001
            LOGGER.info(
                "Logout after %s collect: name=%s ip=%s ok=false error=%s",
                source or "unknown",
                printer.name,
                printer.ip,
                exc,
            )

    @staticmethod
    def parse_device_info(html: str) -> dict[str, str]:
        patterns = {
            "model_name": r"Model Name</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "machine_id": r"Machine ID</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "mac_address": r"MAC(?:\s+Address)?</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([0-9A-Fa-f:\-]{12,17})</td>",
            "ethernet_address": r"Ethernet(?:\s+Address)?</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([0-9A-Fa-f:\-]{12,17})</td>",
            "hardware_address": r"Hardware(?:\s+Address)?</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([0-9A-Fa-f:\-]{12,17})</td>",
            "total_memory": r"Total Memory</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "document_server_capacity": r"Document Server</td>\s*<td[^>]*>:</td>\s*<td[^>]*>Capacity\s*:\s*([^<]+)</td>",
            "document_server_free_space": r"Free Space\s*:\s*([^<%]+)</td>",
            "system_version": r"System</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "nib_version": r"NIB</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "web_image_monitor_version": r"Web Image Monitor</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "adobe_postscript3_version": r"Adobe PostScript 3</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "adobe_pdf_version": r"Adobe PDF</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "rpcs_version": r"RPCS</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "pcl5e_version": r"PCL 5e Emulation</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
            "pclxl_version": r"PCL XL Emulation</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([^<]+)</td>",
        }
        parsed: dict[str, str] = {}
        for key, pattern in patterns.items():
            match = re.search(pattern, html, re.S)
            if match:
                parsed[key] = match.group(1).strip()
        # Normalize MAC-like fields if available.
        mac_candidates = [parsed.get("mac_address", ""), parsed.get("ethernet_address", ""), parsed.get("hardware_address", "")]
        for value in mac_candidates:
            raw = str(value or "").strip()
            if not raw:
                continue
            cleaned = raw.replace("-", ":").upper()
            if re.fullmatch(r"[0-9A-F]{2}(?::[0-9A-F]{2}){5}", cleaned):
                parsed["mac_address"] = cleaned
                break
        return parsed

    @staticmethod
    def parse_status(html: str) -> dict[str, str]:
        data: dict[str, str] = {}

        if re.search(r"<dt[^>]*>System</dt>\s*<dd[^>]*>.*?Status OK", html, re.S):
            data["system_status"] = "OK"
        elif re.search(r"<dt[^>]*>System</dt>\s*<dd[^>]*>.*?Alert", html, re.S):
            data["system_status"] = "Alert"

        def parse_alerts(section: str, key_prefix: str) -> None:
            match = re.search(rf"<dt[^>]*>{section}</dt>.*?<ul>(.*?)</ul>", html, re.S)
            if not match:
                return
            alerts = [a.strip() for a in re.findall(r"<li>([^<]+)</li>", match.group(1))]
            alerts = [a for a in alerts if a]
            if alerts:
                data[f"{key_prefix}_alerts"] = "; ".join(alerts)
            else:
                data[f"{key_prefix}_status"] = "OK"

        parse_alerts("Printer", "printer")
        parse_alerts("Copier", "copier")
        parse_alerts("Scanner", "scanner")

        if re.search(r"<dt[^>]*>Black</dt>\s*<dd[^>]*>.*?Status OK", html, re.S):
            data["toner_black"] = "OK"

        for tray_num, title in re.findall(r"<dt[^>]*>Tray (\d+)</dt>\s*<dd[^>]*>.*?title=['\"]([^'\"]+)['\"]", html, re.S):
            data[f"tray_{tray_num}_status"] = title

        bypass = re.search(r"<dt[^>]*>Bypass Tray</dt>\s*<dd[^>]*>.*?title=['\"]([^'\"]+)['\"]", html, re.S)
        if bypass:
            data["bypass_tray_status"] = bypass.group(1)
        return data

    @staticmethod
    def parse_counter(html: str) -> dict[str, str]:
        patterns = {
            "total": r"Total</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "copier_bw": r"Copier</div>.*?Black &amp; White</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "printer_bw": r"Printer</div>.*?Black &amp; White</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "fax_bw": r"Fax</div>.*?Black &amp; White</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "send_tx_total_bw": r"Send/TX Total</div>.*?Black &amp; White</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "send_tx_total_color": r"Send/TX Total</div>.*?Color</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "fax_transmission_total": r"Fax Transmission</div>.*?Total</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "scanner_send_bw": r"Scanner Send</div>.*?Black &amp; White</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "scanner_send_color": r"Scanner Send</div>.*?Color</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "coverage_copier_bw": r"Copier</td>.*?B &amp; W Coverage</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>\s*<td[^>]*>%</td>",
            "coverage_printer_bw": r"Printer</td>.*?B &amp; W Coverage</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>\s*<td[^>]*>%</td>",
            "coverage_fax_bw": r"Fax</td>.*?B &amp; W Coverage</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>\s*<td[^>]*>%</td>",
            "a3_dlt": r"A3/DLT</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
            "duplex": r"Duplex</td>\s*<td[^>]*>:</td>\s*<td[^>]*>([\d,\s]+)</td>",
        }
        parsed: dict[str, str] = {key: "" for key in patterns}
        for key, pattern in patterns.items():
            match = re.search(pattern, html, re.S)
            if match:
                parsed[key] = re.sub(r"[^\d]", "", match.group(1))
        return parsed

    def _login(self, session: requests.Session, printer: Printer) -> None:
        if not printer.user:
            raise ValueError("username is required for login")
        base_url = f"http://{printer.ip}"
        session.get(urljoin(base_url, "/web/guest/en/websys/webArch/mainFrame.cgi"), timeout=10).raise_for_status()
        errors: list[str] = []
        # 1) Prefer authForm.cgi flow (common on older Ricoh Web Image Monitor).
        try:
            auth_url = urljoin(base_url, "/web/guest/en/websys/webArch/authForm.cgi")
            auth_page = session.get(auth_url, timeout=10)
            auth_page.raise_for_status()
            auth_html = auth_page.text
            action_match = re.search(r"<form[^>]*action=['\"]([^'\"]+)['\"]", auth_html, re.I)
            # Resolve relative form action against authForm URL to keep full webArch path.
            post_url = urljoin(auth_url, action_match.group(1)) if action_match else auth_url
            token_match = re.search(r"name=['\"]wimToken['\"]\s+value=['\"]([^'\"]+)['\"]", auth_html)
            wim_token = token_match.group(1) if token_match else ""
            encoded_user = base64.b64encode(printer.user.encode("utf-8")).decode("ascii")
            encoded_password = base64.b64encode((printer.password or "").encode("utf-8")).decode("ascii")
            form = {
                "userid": encoded_user,
                "password": encoded_password,
                "loginUserName": printer.user,
                "loginPassword": printer.password or "",
                "wimToken": wim_token,
                "open": "",
                "title": "",
            }
            resp = session.post(
                post_url,
                data=form,
                headers={"Referer": auth_url},
                timeout=10,
            )
            resp.raise_for_status()
            text = resp.text
            if "authForm.cgi" not in text and "login.cgi" not in text and "Login User Name" not in text:
                return
            errors.append("authForm flow still on login page")
        except Exception as exc:  # noqa: BLE001
            errors.append(f"authForm flow failed: {exc}")

        # 2) Fallback to legacy login.cgi flow.
        login_page = session.get(urljoin(base_url, "/web/guest/en/websys/webArch/login.cgi"), timeout=10)
        login_page.raise_for_status()
        html = login_page.text
        token_match = re.search(r"name=['\"]wimToken['\"]\s+value=['\"]([^'\"]+)['\"]", html)
        wim_token = token_match.group(1) if token_match else "689773994"
        form = {
            "userid": base64.b64encode(printer.user.encode("utf-8")).decode("ascii"),
            "password": base64.b64encode((printer.password or "").encode("utf-8")).decode("ascii"),
            "wimToken": wim_token,
            "open": "",
        }
        resp = session.post(
            urljoin(base_url, "/web/guest/en/websys/webArch/login.cgi"),
            data=form,
            headers={"Referer": urljoin(base_url, "/web/guest/en/websys/webArch/login.cgi")},
            timeout=10,
        )
        resp.raise_for_status()
        if "login.cgi" in resp.text or "Login User Name" in resp.text or "authForm.cgi" in resp.text:
            raise RuntimeError("login failed; " + "; ".join(errors))
        self._warmup_address_context(session, printer)

    def _login_auth_form_only(self, session: requests.Session, printer: Printer) -> None:
        if not printer.user:
            raise ValueError("username is required for login")
        base_url = f"http://{printer.ip}"
        session.get(urljoin(base_url, "/web/guest/en/websys/webArch/mainFrame.cgi"), timeout=10).raise_for_status()
        auth_url = urljoin(base_url, "/web/guest/en/websys/webArch/authForm.cgi")
        auth_page = session.get(auth_url, timeout=10)
        auth_page.raise_for_status()
        auth_html = auth_page.text
        action_match = re.search(r"<form[^>]*action=['\"]([^'\"]+)['\"]", auth_html, re.I)
        # Resolve relative form action against authForm URL to keep full webArch path.
        post_url = urljoin(auth_url, action_match.group(1)) if action_match else auth_url
        token_match = re.search(r"name=['\"]wimToken['\"]\s+value=['\"]([^'\"]+)['\"]", auth_html)
        wim_token = token_match.group(1) if token_match else ""
        encoded_user = base64.b64encode(printer.user.encode("utf-8")).decode("ascii")
        encoded_password = base64.b64encode((printer.password or "").encode("utf-8")).decode("ascii")
        form = {
            "userid": encoded_user,
            "password": encoded_password,
            "loginUserName": printer.user,
            "loginPassword": printer.password or "",
            "wimToken": wim_token,
            "open": "",
            "title": "",
        }
        resp = session.post(
            post_url,
            data=form,
            headers={"Referer": auth_url},
            timeout=10,
        )
        resp.raise_for_status()
        text = resp.text
        if "authForm.cgi" in text or "login.cgi" in text or "Login User Name" in text:
            raise RuntimeError("authForm login failed")
        self._warmup_address_context(session, printer)

    def _reset_web_session(self, session: requests.Session, printer: Printer) -> None:
        base_url = f"http://{printer.ip}"
        # Best-effort logout/cleanup so address-book login starts from a clean state.
        urls = [
            "/web/entry/en/websys/webArch/logout.cgi",
            "/web/guest/en/websys/webArch/logout.cgi",
            "/web/entry/en/websys/webArch/mainFrame.cgi",
            "/web/guest/en/websys/webArch/mainFrame.cgi",
        ]
        for target in urls:
            try:
                session.get(urljoin(base_url, target), timeout=8)
            except Exception:  # noqa: BLE001
                continue
        try:
            session.cookies.clear()
        except Exception:  # noqa: BLE001
            return

    def reset_web_session(self, printer: Printer) -> None:
        # Public hook used by web layer before address-book operations.
        session = requests.Session()
        session.headers.update({"User-Agent": "printer-agent/0.1"})
        self._reset_web_session(session, printer)

    def _warmup_address_context(self, session: requests.Session, printer: Printer) -> None:
        base_url = f"http://{printer.ip}"
        urls = [
            "/web/entry/en/websys/webArch/mainFrame.cgi?open=websys/easySecurity/getEasySecurity.cgi",
            "/web/entry/en/websys/easySecurity/getEasySecurity.cgi",
            "/web/entry/en/address/adrsList.cgi?modeIn=LIST_ALL",
        ]
        for target in urls:
            try:
                session.get(urljoin(base_url, target), timeout=10).raise_for_status()
            except Exception:  # noqa: BLE001
                continue

    def create_http_client(self, printer: Printer) -> requests.Session:
        session = requests.Session()
        session.headers.update({"User-Agent": "printer-agent/0.1"})
        if printer.user:
            self._reset_web_session(session, printer)
            self._login(session, printer)
        else:
            session.get(f"http://{printer.ip}/web/guest/en/websys/webArch/mainFrame.cgi", timeout=10).raise_for_status()
        return session

    def create_http_client_auth_form_only(self, printer: Printer) -> requests.Session:
        session = requests.Session()
        session.headers.update({"User-Agent": "printer-agent/0.1"})
        if printer.user:
            self._reset_web_session(session, printer)
            self._login_auth_form_only(session, printer)
        else:
            session.get(f"http://{printer.ip}/web/guest/en/websys/webArch/mainFrame.cgi", timeout=10).raise_for_status()
        return session

    def authenticate_and_get(self, session: requests.Session, printer: Printer, target_url: str) -> str:
        full_url = f"http://{printer.ip}{target_url}"
        response = session.get(full_url, timeout=10)
        response.raise_for_status()
        html = response.text
        if ("authForm.cgi" in html or "login.cgi" in html) and printer.user:
            self._login(session, printer)
            response = session.get(full_url, timeout=10)
            response.raise_for_status()
            html = response.text
        # Some models require EasySecurity/mainFrame context before address pages are accessible.
        if "PERMISSION_E" in html and printer.user:
            self._warmup_address_context(session, printer)
            response = session.get(full_url, timeout=10)
            response.raise_for_status()
            html = response.text
        return html

    @staticmethod
    def _extract_wim_token(html: str) -> str:
        match = re.search(r"name=['\"]wimToken['\"]\s+value=['\"]([^'\"]+)['\"]", html)
        if not match:
            raise ValueError("wimToken not found")
        return match.group(1)

    @staticmethod
    def _extract_user_authentication_method(html: str) -> str:
        for match in re.finditer(r"<input[^>]*>", html, re.I | re.S):
            tag = match.group(0)
            name_match = re.search(r"name=['\"]([^'\"]+)['\"]", tag, re.I)
            if not name_match or name_match.group(1).strip() != "userAuthenticationMethod":
                continue
            if re.search(r"\bchecked\b", tag, re.I):
                value_match = re.search(r"value=['\"]([^'\"]*)['\"]", tag, re.I | re.S)
                return str(value_match.group(1) if value_match else "").strip().upper()
        hidden_match = re.search(
            r"<input[^>]*name=['\"]userAuthenticationMethod['\"][^>]*value=['\"]([^'\"]*)['\"][^>]*>",
            html,
            re.I | re.S,
        )
        if hidden_match:
            return str(hidden_match.group(1) or "").strip().upper()
        generic_match = re.search(r"\b(RADIO_OFF|UA_[A-Z_]+)\b", html)
        if generic_match:
            return str(generic_match.group(1) or "").strip().upper()
        return ""

    def read_machine_control_state(self, printer: Printer) -> dict[str, Any]:
        config_url = "/web/entry/en/websys/config/getUserAuthenticationManager.cgi"
        session = self.create_http_client(printer)
        html = self.authenticate_and_get(session, printer, config_url)
        method = self._extract_user_authentication_method(html)
        enabled = method == "RADIO_OFF"
        return {
            "enabled": enabled,
            "method": method,
            "known": bool(method),
            "source": config_url,
        }

    def _submit_user_authentication_settings(
        self,
        printer: Printer,
        *,
        method: str,
        copier_bw: bool,
        printer_bw: bool,
        printer_pc_control: bool,
        document_server: bool,
        fax: bool,
        scanner: bool,
        browser: bool,
    ) -> None:
        config_url = "/web/entry/en/websys/config/getUserAuthenticationManager.cgi"
        session = self.create_http_client(printer)
        html = self.authenticate_and_get(session, printer, config_url)
        wim_token = self._extract_wim_token(html)

        form: list[tuple[str, str]] = [
            ("wimToken", wim_token),
            ("accessConf", "MDowOjA6MDoxOjE6MTowOjA6MDowOjA6"),
            ("title", "MENU_USERAUTH"),
            ("userAuthenticationRW", "3"),
            ("userAuthenticationMethod", method),
            # Copier/Printer have hidden defaults + checkbox values in Ricoh forms.
            ("userCodeCopy", "true" if copier_bw else "false"),
            ("userCodeCopy", ""),
            ("userCodeCopy", ""),
            ("userCodeCopy", ""),
            ("userCodePrinter", "true" if printer_bw else "false"),
            ("userCodePrinter", "true" if printer_pc_control else "false"),
            ("userCodePrinter", ""),
            ("userCodeDocumentBox", "true" if document_server else "false"),
            ("userCodeFax", "true" if fax else "false"),
            ("userCodeScaner", "true" if scanner else "false"),
            ("userCodeMfpBrowser", "true" if browser else "false"),
        ]
        resp = session.post(
            f"http://{printer.ip}/web/entry/en/websys/config/setUserAuthenticationManager.cgi",
            data=form,
            headers={"Referer": f"http://{printer.ip}{config_url}"},
            timeout=10,
        )
        resp.raise_for_status()

    def enable_machine(self, printer: Printer) -> None:
        # Device Enable => EasySecurity OFF.
        self._submit_user_authentication_settings(
            printer,
            method="RADIO_OFF",
            copier_bw=False,
            printer_bw=False,
            printer_pc_control=False,
            document_server=False,
            fax=False,
            scanner=False,
            browser=False,
        )

    def lock_machine(self, printer: Printer) -> None:
        # Device Disable => UserCode ON with all restrictions from requested profile:
        # Copier B&W=ON, Printer B&W=ON, PC Control=OFF, Document Server/Fax/Scanner/Browser=ON.
        self._submit_user_authentication_settings(
            printer,
            method="UA_USER_CODE",
            copier_bw=True,
            printer_bw=True,
            printer_pc_control=False,
            document_server=True,
            fax=True,
            scanner=True,
            browser=True,
        )

    def disable_machine(self, printer: Printer) -> None:
        self.lock_machine(printer)

    def read_address_list_with_client(self, session: requests.Session, printer: Printer) -> str:
        urls = [
            "/web/entry/en/address/adrsList.cgi",
            "/web/entry/en/address/adrsList.cgi?modeIn=LIST_ALL",
            "/web/entry/en/address/adrsListAll.cgi",
            "/web/entry/en/address/getAddressList.cgi",
            "/web/guest/en/address/adrsList.cgi",
            "/web/guest/en/address/adrsList.cgi?modeIn=LIST_ALL",
            "/web/guest/en/address/adrsListAll.cgi",
            "/web/guest/en/address/getAddressList.cgi",
        ]
        for target in urls:
            try:
                html = self.authenticate_and_get(session, printer, target)
                html_len = len(html)
                has_address_markers = "Address List" in html or "adrsList" in html
                has_login_markers = "login.cgi" in html or "Login User Name" in html or "authForm.cgi" in html
                self._append_address_debug(
                    "address_list:url_check "
                    f"ip={printer.ip} target={target} html_len={html_len} "
                    f"has_address_markers={has_address_markers} has_login_markers={has_login_markers}"
                )
                LOGGER.info(
                    "Address list URL check: ip=%s target=%s html_len=%s has_address_markers=%s has_login_markers=%s",
                    printer.ip,
                    target,
                    html_len,
                    has_address_markers,
                    has_login_markers,
                )
                if has_address_markers and not has_login_markers:
                    return html
            except Exception as exc:  # noqa: BLE001
                self._append_address_debug(
                    f"address_list:url_error ip={printer.ip} target={target} error={type(exc).__name__}:{str(exc)}"
                )
                LOGGER.warning("Address list URL error: ip=%s target=%s error=%s", printer.ip, target, exc)
                continue
        return self.authenticate_and_get(session, printer, "/web/guest/en/address/adrsList.cgi")

    def read_address_list(self, printer: Printer) -> str:
        session = self.create_http_client(printer)
        return self.read_address_list_with_client(session, printer)

    @staticmethod
    def _strip_html(input_value: str) -> str:
        text = re.sub(r"<[^>]*>", "", input_value)
        return unescape(text).strip()

    @staticmethod
    def _extract_hidden_inputs(html: str) -> dict[str, str]:
        result: dict[str, str] = {}
        for match in re.finditer(r"<input[^>]*>", html, re.I | re.S):
            tag = match.group(0)
            type_match = re.search(r"type=['\"]([^'\"]+)['\"]", tag, re.I)
            input_type = (type_match.group(1).strip().lower() if type_match else "").strip()
            if input_type and input_type != "hidden":
                continue
            name_match = re.search(r"name=['\"]([^'\"]+)['\"]", tag, re.I)
            if not name_match:
                continue
            key = name_match.group(1).strip()
            if not key:
                continue
            value_match = re.search(r"value=['\"]([^'\"]*)['\"]", tag, re.I | re.S)
            value = value_match.group(1) if value_match else ""
            result[key] = unescape(value)
        return result

    @staticmethod
    def _pick_field_key(keys: list[str], candidates: list[str]) -> str:
        lowered_map = {k.lower(): k for k in keys}
        for cand in candidates:
            hit = lowered_map.get(cand.lower())
            if hit:
                return hit
        return ""

    def create_address_user_wizard(
        self,
        printer: Printer,
        name: str,
        email: str = "",
        folder: str = "",
        user_code: str = "",
        fields: dict[str, Any] | None = None,
        desired_registration_no: str | None = None,
        allow_auto_update: bool = True,
    ) -> dict[str, Any]:
        session = self.create_http_client_auth_form_only(printer)
        set_url = "/web/entry/en/address/adrsSetUserWizard.cgi"
        get_wizard_url = "/web/entry/en/address/adrsGetUserWizard.cgi"
        # Warm up context from address list first; many Ricoh models require this before wizard page.
        warmup_targets = [
            "/web/entry/en/address/adrsList.cgi?modeIn=LIST_ALL",
            "/web/guest/en/address/adrsList.cgi?modeIn=LIST_ALL",
        ]
        for target in warmup_targets:
            try:
                self.authenticate_and_get(session, printer, target)
                break
            except Exception:  # noqa: BLE001
                continue
        list_html_ctx = ""
        list_url_ctx = ""
        for target in warmup_targets:
            try:
                candidate = self.authenticate_and_get(session, printer, target)
                if candidate.strip() and "login.cgi" not in candidate and "authForm.cgi" not in candidate:
                    list_html_ctx = candidate
                    list_url_ctx = target
                    break
            except Exception:  # noqa: BLE001
                continue
        list_defaults_ctx = self._extract_hidden_inputs(list_html_ctx) if list_html_ctx else {}
        list_token_ctx = str(list_defaults_ctx.get("wimToken", "")).strip()
        if not list_token_ctx and list_html_ctx:
            try:
                list_token_ctx = self._extract_wim_token(list_html_ctx)
            except Exception:  # noqa: BLE001
                list_token_ctx = ""

        # Primary flow from captured HAR: POST multi-step wizard (ADDUSER -> BASE -> MAIL -> FOLDER -> CONFIRM).
        if list_token_ctx:
            try:
                list_referer = f"http://{printer.ip}{list_url_ctx}" if list_url_ctx else f"http://{printer.ip}/web/entry/en/address/adrsList.cgi?modeIn=LIST_ALL"
                wizard_referer = f"http://{printer.ip}{get_wizard_url}"
                wizard_url = f"http://{printer.ip}{get_wizard_url}"
                set_full_url = f"http://{printer.ip}{set_url}"
                LOGGER.info(
                    "Address create wizard(start): ip=%s name=%s has_email=%s has_folder=%s has_user_code=%s token=%s list_url=%s",
                    printer.ip,
                    str(name or "").strip(),
                    bool(str(email or "").strip()),
                    bool(str(folder or "").strip()),
                    bool(str(user_code or "").strip()),
                    bool(list_token_ctx),
                    list_url_ctx or "-",
                )

                open_resp = session.post(
                    wizard_url,
                    data={
                        "mode": "ADDUSER",
                        "outputSpecifyModeIn": "DEFAULT",
                        "wimToken": list_token_ctx,
                    },
                    headers={"Referer": list_referer},
                    timeout=15,
                )
                open_resp.raise_for_status()
                LOGGER.info(
                    "Address create wizard(open): ip=%s status=%s referer=%s",
                    printer.ip,
                    open_resp.status_code,
                    list_referer,
                )

                next_index = "00001"
                desired_reg = str(desired_registration_no or "").strip()
                if desired_reg:
                    if desired_reg.isdigit():
                        next_index = desired_reg.zfill(5)
                    else:
                        desired_reg = ""
                try:
                    raw_existing = self.get_address_list_ajax_with_client(session, printer)
                    existing_entries = self.parse_ajax_address_list(raw_existing)
                    nums: list[int] = []
                    for entry in existing_entries:
                        reg = str(entry.registration_no or "").strip()
                        if reg.isdigit():
                            nums.append(int(reg))
                    try:
                        if list_html_ctx:
                            html_existing = self.parse_address_list(list_html_ctx)
                            for entry in html_existing:
                                reg = str(entry.registration_no or "").strip()
                                if reg.isdigit():
                                    nums.append(int(reg))
                    except Exception:  # noqa: BLE001
                        pass
                    max_seen = max(nums) if nums else 0
                    hint_seen = int(self._address_index_hint_by_ip.get(str(printer.ip or "").strip(), 0) or 0)
                    next_index = f"{max(max_seen, hint_seen) + 1:05d}"
                except Exception:  # noqa: BLE001
                    hint_seen = int(self._address_index_hint_by_ip.get(str(printer.ip or "").strip(), 0) or 0)
                    next_index = f"{hint_seen + 1:05d}" if hint_seen > 0 else "00001"
                LOGGER.info(
                    "Address create wizard(index): ip=%s next_index=%s desired_reg=%s",
                    printer.ip,
                    next_index,
                    desired_reg or "-",
                )

                base_form: list[tuple[str, str]] = [
                    ("mode", "ADDUSER"),
                    ("step", "BASE"),
                    ("wimToken", list_token_ctx),
                    ("entryIndexIn", next_index),
                    ("entryNameIn", str(name or "").strip()),
                    ("entryDisplayNameIn", str(name or "").strip()),
                    ("entryTagInfoIn", "1"),
                    ("entryTagInfoIn", "1"),
                    ("entryTagInfoIn", "1"),
                    ("entryTagInfoIn", "1"),
                ]
                base_resp = session.post(
                    set_full_url,
                    data=base_form,
                    headers={"Referer": wizard_referer},
                    timeout=15,
                )
                base_resp.raise_for_status()
                LOGGER.info("Address create wizard(step=BASE): ip=%s status=%s", printer.ip, base_resp.status_code)

                step_list = ["BASE"]
                if str(email or "").strip():
                    mail_resp = session.post(
                        set_full_url,
                        data={
                            "mode": "ADDUSER",
                            "step": "MAIL",
                            "wimToken": list_token_ctx,
                            "mailAddressIn": str(email).strip(),
                        },
                        headers={"Referer": wizard_referer},
                        timeout=15,
                    )
                    mail_resp.raise_for_status()
                    step_list.append("MAIL")
                    LOGGER.info("Address create wizard(step=MAIL): ip=%s status=%s", printer.ip, mail_resp.status_code)
                else:
                    LOGGER.info("Address create wizard(step=MAIL): ip=%s skipped=yes", printer.ip)

                if str(folder or "").strip():
                    folder_resp = session.post(
                        set_full_url,
                        data={
                            "mode": "ADDUSER",
                            "step": "FOLDER",
                            "wimToken": list_token_ctx,
                            "folderProtocolIn": "SMB_O",
                            "folderPortNoIn": "21",
                            "folderServerNameIn": "",
                            "folderPathNameIn": str(folder).strip(),
                            "folderAuthUserNameIn": "",
                            "wk_folderPasswordIn": "",
                            "folderPasswordIn": "",
                            "wk_folderPasswordConfirmIn": "",
                            "folderPasswordConfirmIn": "",
                        },
                        headers={"Referer": wizard_referer},
                        timeout=15,
                    )
                    folder_resp.raise_for_status()
                    step_list.append("FOLDER")
                    LOGGER.info(
                        "Address create wizard(step=FOLDER): ip=%s status=%s folder=%s",
                        printer.ip,
                        folder_resp.status_code,
                        str(folder or "").strip(),
                    )
                else:
                    LOGGER.info("Address create wizard(step=FOLDER): ip=%s skipped=yes", printer.ip)

                confirm_form: list[tuple[str, str]] = [("wimToken", list_token_ctx)]
                for step_name in step_list:
                    confirm_form.append(("stepListIn", step_name))
                confirm_form.extend([("mode", "ADDUSER"), ("step", "CONFIRM")])
                confirm_resp = session.post(
                    set_full_url,
                    data=confirm_form,
                    headers={"Referer": wizard_referer},
                    timeout=15,
                )
                confirm_resp.raise_for_status()
                LOGGER.info(
                    "Address create wizard(step=CONFIRM): ip=%s status=%s step_list=%s",
                    printer.ip,
                    confirm_resp.status_code,
                    ",".join(step_list),
                )

                verify_raw = ""
                verify_entries: list[AddressEntry] = []
                try:
                    verify_raw = self.get_address_list_ajax_with_client(session, printer)
                    verify_entries = self.parse_ajax_address_list(verify_raw)
                except Exception:  # noqa: BLE001
                    verify_raw = ""
                    verify_entries = []
                created = next(
                    (
                        e
                        for e in verify_entries
                        if str(e.name or "").strip().lower() == str(name or "").strip().lower()
                    ),
                    None,
                )
                if not created and str(next_index or "").strip():
                    created = next(
                        (
                            e
                            for e in verify_entries
                            if str(e.registration_no or "").strip() == str(next_index).strip()
                        ),
                        None,
                    )
                if not created and verify_entries:
                    numeric_entries = [e for e in verify_entries if str(e.registration_no or "").strip().isdigit()]
                    if numeric_entries:
                        created = max(numeric_entries, key=lambda e: int(str(e.registration_no or "0").strip()))
                try:
                    ip_key = str(printer.ip or "").strip()
                    if str(next_index or "").strip().isdigit():
                        self._address_index_hint_by_ip[ip_key] = max(
                            int(self._address_index_hint_by_ip.get(ip_key, 0) or 0),
                            int(str(next_index).strip()),
                        )
                    if created and str(created.registration_no or "").strip().isdigit():
                        self._address_index_hint_by_ip[ip_key] = max(
                            int(self._address_index_hint_by_ip.get(ip_key, 0) or 0),
                            int(str(created.registration_no).strip()),
                        )
                except Exception:  # noqa: BLE001
                    pass
                if not created:
                    try:
                        html_list = self.read_address_list_with_client(session, printer)
                        html_entries = self.parse_address_list(html_list)
                        created = next(
                            (
                                e
                                for e in html_entries
                                if str(e.name or "").strip().lower() == str(name or "").strip().lower()
                            ),
                            None,
                        )
                        if html_entries:
                            verify_entries = html_entries
                        LOGGER.info(
                            "Address create wizard(verify-html): ip=%s html_entries=%s created_reg=%s",
                            printer.ip,
                            len(html_entries),
                            str(created.registration_no) if created else "",
                        )
                    except Exception:  # noqa: BLE001
                        LOGGER.exception("Address create wizard(verify-html): ip=%s status=error", printer.ip)
                LOGGER.info(
                    "Address create wizard(verify): ip=%s verify_entries=%s created_reg=%s",
                    printer.ip,
                    len(verify_entries),
                    str(created.registration_no) if created else "",
                )

                auto_updated = False
                auto_update_error = ""
                update_reg = str(created.registration_no or "").strip() if created else str(next_index or "").strip()
                if update_reg and allow_auto_update:
                    if not created:
                        created = AddressEntry(
                            type="User",
                            registration_no=update_reg,
                            name=str(name or "").strip(),
                            user_code=str(user_code or "").strip(),
                            date_last_used="-",
                            email_address="",
                            folder="",
                        )
                    need_email = bool(str(email or "").strip()) and str(created.email_address or "").strip() in {"", "-", "---"}
                    need_folder = bool(str(folder or "").strip()) and str(created.folder or "").strip() in {"", "-", "---"}
                    LOGGER.info(
                        "Address create wizard(auto-update-check): ip=%s reg=%s need_email=%s need_folder=%s current_email=%s current_folder=%s",
                        printer.ip,
                        update_reg,
                        need_email,
                        need_folder,
                        str(created.email_address or ""),
                        str(created.folder or ""),
                    )
                    if need_email or need_folder:
                        try:
                            self.modify_address_user_wizard(
                                printer=printer,
                                registration_no=update_reg,
                                name=str(name or "").strip(),
                                email=str(email or "").strip(),
                                folder=str(folder or "").strip(),
                                user_code=str(user_code or "").strip(),
                                fields=fields if isinstance(fields, dict) else None,
                            )
                            auto_updated = True
                            LOGGER.info(
                                "Address create wizard(auto-update): ip=%s reg=%s status=success",
                                printer.ip,
                                update_reg,
                            )
                            try:
                                verify_raw = self.get_address_list_ajax_with_client(session, printer)
                                verify_entries = self.parse_ajax_address_list(verify_raw)
                                created = next(
                                    (
                                        e
                                        for e in verify_entries
                                        if str(e.registration_no or "").strip() == update_reg
                                    ),
                                    created,
                                )
                                LOGGER.info(
                                    "Address create wizard(auto-update-verify): ip=%s reg=%s email=%s folder=%s verify_entries=%s",
                                    printer.ip,
                                    update_reg,
                                    str(created.email_address or ""),
                                    str(created.folder or ""),
                                    len(verify_entries),
                                )
                            except Exception:  # noqa: BLE001
                                LOGGER.exception(
                                    "Address create wizard(auto-update-verify): ip=%s reg=%s status=error",
                                    printer.ip,
                                    update_reg,
                                )
                                pass
                        except Exception as exc:  # noqa: BLE001
                            auto_update_error = f"{type(exc).__name__}:{exc}"
                            LOGGER.exception(
                                "Address create wizard(auto-update): ip=%s reg=%s status=error error=%s",
                                printer.ip,
                                update_reg,
                                auto_update_error,
                            )
                LOGGER.info(
                    "Address create wizard(done): ip=%s name=%s reg=%s auto_updated=%s auto_update_error=%s",
                    printer.ip,
                    str(name or "").strip(),
                    str(created.registration_no) if created else "",
                    auto_updated,
                    auto_update_error or "-",
                )

                return {
                    "printer_name": printer.name,
                    "ip": printer.ip,
                    "ok": True,
                    "endpoint": set_url,
                    "name": str(name or "").strip(),
                    "http_status": confirm_resp.status_code,
                    "response_excerpt": (confirm_resp.text or "")[:600],
                    "verify_count": len(verify_entries),
                    "expected_registration_no": str(next_index or ""),
                    "verify_sample_regs": [str(e.registration_no or "") for e in verify_entries[:5]],
                    "created_registration_no": str(created.registration_no) if created else "",
                    "created_email": str(created.email_address) if created else "",
                    "created_folder": str(created.folder) if created else "",
                    "auto_updated_after_create": auto_updated,
                    "auto_update_error": auto_update_error,
                    "fallback_mode": "wizard_multistep_har",
                    "timestamp": self._timestamp(),
                }
            except Exception:  # noqa: BLE001
                LOGGER.exception("Address create wizard(flow=multistep_har): ip=%s status=error", printer.ip)
                pass

        get_candidates = [
            "/web/entry/en/address/adrsGetUserWizard.cgi?modeIn=ADD&entryTypeIn=1",
            "/web/entry/en/address/adrsGetUserWizard.cgi?entryTypeIn=1",
            "/web/entry/en/address/adrsGetUserWizard.cgi?modeIn=ADD",
            "/web/entry/en/address/adrsGetUserWizard.cgi",
            "/web/guest/en/address/adrsGetUserWizard.cgi?modeIn=ADD&entryTypeIn=1",
            "/web/guest/en/address/adrsGetUserWizard.cgi?entryTypeIn=1",
            "/web/guest/en/address/adrsGetUserWizard.cgi?modeIn=ADD",
            "/web/guest/en/address/adrsGetUserWizard.cgi",
        ]
        html = ""
        get_url = ""
        errors: list[str] = []
        for target in get_candidates:
            try:
                candidate_html = self.authenticate_and_get(session, printer, target)
                if not candidate_html.strip():
                    errors.append(f"{target}:empty")
                    continue
                if "login.cgi" in candidate_html or "authForm.cgi" in candidate_html:
                    errors.append(f"{target}:login_page")
                    continue
                html = candidate_html
                get_url = target
                break
            except Exception as exc:  # noqa: BLE001
                errors.append(f"{target}:{type(exc).__name__}:{exc}")
                if list_token_ctx:
                    try:
                        post_form = {
                            "wimToken": list_token_ctx,
                            "modeIn": "ADD",
                            "entryTypeIn": "1",
                            "open": "",
                            "title": "",
                        }
                        post_resp = session.post(
                            f"http://{printer.ip}{target}",
                            data=post_form,
                            headers={"Referer": f"http://{printer.ip}{list_url_ctx}"} if list_url_ctx else {},
                            timeout=15,
                        )
                        post_text = post_resp.text or ""
                        if post_resp.status_code < 400 and "login.cgi" not in post_text and "authForm.cgi" not in post_text and post_text.strip():
                            html = post_text
                            get_url = target
                            break
                        errors.append(f"{target}:post_open_failed_status={post_resp.status_code}")
                    except Exception as post_exc:  # noqa: BLE001
                        errors.append(f"{target}:post_open_error={type(post_exc).__name__}:{post_exc}")
                continue
        if not html:
            # First fallback: try Detail Input endpoints (non-wizard) which are more stable on some models.
            detail_get_candidates = [
                "/web/entry/en/address/adrsGetUser.cgi?modeIn=ADD",
                "/web/entry/en/address/adrsGetUser.cgi",
                "/web/guest/en/address/adrsGetUser.cgi?modeIn=ADD",
                "/web/guest/en/address/adrsGetUser.cgi",
            ]
            detail_set_candidates = [
                "/web/entry/en/address/adrsSetUser.cgi",
                "/web/guest/en/address/adrsSetUser.cgi",
            ]
            detail_errors: list[str] = []
            for detail_get in detail_get_candidates:
                try:
                    detail_html = ""
                    try:
                        detail_html = self.authenticate_and_get(session, printer, detail_get)
                    except Exception as detail_get_exc:  # noqa: BLE001
                        detail_errors.append(f"{detail_get}:get_error={type(detail_get_exc).__name__}:{detail_get_exc}")
                        if list_token_ctx:
                            try:
                                detail_post = session.post(
                                    f"http://{printer.ip}{detail_get}",
                                    data={
                                        "wimToken": list_token_ctx,
                                        "modeIn": "ADD",
                                        "entryTypeIn": "1",
                                        "open": "",
                                        "title": "",
                                    },
                                    headers={"Referer": f"http://{printer.ip}{list_url_ctx}"} if list_url_ctx else {},
                                    timeout=15,
                                )
                                if detail_post.status_code < 400:
                                    detail_html = detail_post.text or ""
                                else:
                                    detail_errors.append(f"{detail_get}:post_status={detail_post.status_code}")
                            except Exception as detail_post_exc:  # noqa: BLE001
                                detail_errors.append(
                                    f"{detail_get}:post_error={type(detail_post_exc).__name__}:{detail_post_exc}"
                                )
                    if not detail_html.strip():
                        detail_errors.append(f"{detail_get}:empty")
                        continue
                    if "login.cgi" in detail_html or "authForm.cgi" in detail_html:
                        detail_errors.append(f"{detail_get}:login_page")
                        continue
                    detail_defaults = self._extract_hidden_inputs(detail_html)
                    token = detail_defaults.get("wimToken", "")
                    if not token:
                        token = self._extract_wim_token(detail_html)
                    detail_defaults["wimToken"] = token

                    key_list = list(detail_defaults.keys())
                    name_key = self._pick_field_key(
                        key_list,
                        ["entryNameIn", "nameIn", "userNameIn", "displayNameIn", "entryDisplayNameIn", "name"],
                    )
                    email_key = self._pick_field_key(
                        key_list,
                        ["emailAddressIn", "emailIn", "mailAddressIn", "entryMailAddressIn", "email"],
                    )
                    folder_key = self._pick_field_key(
                        key_list,
                        ["folderPathNameIn", "folderPathIn", "folderIn", "pathIn", "folder"],
                    )
                    user_code_key = self._pick_field_key(
                        key_list,
                        ["userCodeIn", "userCode", "entryUserCodeIn", "codeIn"],
                    )

                    value_variants = [
                        {"name": str(name or "").strip(), "email": str(email or "").strip(), "folder": str(folder or "").strip(), "user_code": str(user_code or "").strip()},
                        {"name": str(name or "").strip(), "email": str(email or "").strip(), "folder": "", "user_code": str(user_code or "").strip()},
                        {"name": str(name or "").strip(), "email": "", "folder": "", "user_code": ""},
                    ]
                    for set_target in detail_set_candidates:
                        for values in value_variants:
                            form = dict(detail_defaults)
                            form[name_key or "entryNameIn"] = values["name"]
                            if values["email"]:
                                form[email_key or "emailAddressIn"] = values["email"]
                            if values["folder"]:
                                form[folder_key or "folderPathNameIn"] = values["folder"]
                            if values["user_code"]:
                                form[user_code_key or "userCodeIn"] = values["user_code"]
                            form.setdefault("open", "")
                            if fields and isinstance(fields, dict):
                                for k, v in fields.items():
                                    key = str(k or "").strip()
                                    if not key:
                                        continue
                                    form[key] = "" if v is None else str(v)
                            resp = session.post(
                                f"http://{printer.ip}{set_target}",
                                data=form,
                                headers={"Referer": f"http://{printer.ip}{detail_get}"},
                                timeout=15,
                            )
                            text = resp.text or ""
                            if resp.status_code >= 400:
                                detail_errors.append(f"set={set_target} status={resp.status_code} from={detail_get}")
                                continue
                            if "login.cgi" in text or "authForm.cgi" in text:
                                detail_errors.append(f"set={set_target} login_redirect from={detail_get}")
                                continue
                            verify_raw = ""
                            verify_entries: list[AddressEntry] = []
                            try:
                                verify_raw = self.get_address_list_ajax_with_client(session, printer)
                                verify_entries = self.parse_ajax_address_list(verify_raw)
                            except Exception:  # noqa: BLE001
                                verify_raw = ""
                                verify_entries = []
                            created = next(
                                (e for e in verify_entries if str(e.name or "").strip().lower() == str(name or "").strip().lower()),
                                None,
                            )
                            return {
                                "printer_name": printer.name,
                                "ip": printer.ip,
                                "ok": True,
                                "endpoint": set_target,
                                "name": str(name or "").strip(),
                                "http_status": resp.status_code,
                                "response_excerpt": text[:600],
                                "verify_count": len(verify_entries),
                                "created_registration_no": str(created.registration_no) if created else "",
                                "fallback_mode": "detail_input_set_user",
                                "timestamp": self._timestamp(),
                            }
                except Exception as exc:  # noqa: BLE001
                    detail_errors.append(f"{detail_get}:{type(exc).__name__}:{exc}")
                    continue

            # Fallback for models that block adrsGetUserWizard but still accept adrsSetUserWizard.
            list_candidates = [
                "/web/entry/en/address/adrsList.cgi?modeIn=LIST_ALL",
                "/web/guest/en/address/adrsList.cgi?modeIn=LIST_ALL",
            ]
            list_html = ""
            list_url = ""
            list_errors: list[str] = []
            for target in list_candidates:
                try:
                    candidate = self.authenticate_and_get(session, printer, target)
                    if not candidate.strip():
                        list_errors.append(f"{target}:empty")
                        continue
                    if "login.cgi" in candidate or "authForm.cgi" in candidate:
                        list_errors.append(f"{target}:login_page")
                        continue
                    list_html = candidate
                    list_url = target
                    break
                except Exception as exc:  # noqa: BLE001
                    list_errors.append(f"{target}:{type(exc).__name__}:{exc}")
                    continue
            if not list_html:
                raise RuntimeError(
                    "cannot open address create wizard; "
                    + " | ".join(errors[-4:])
                    + " || detail_fallback_failed: "
                    + " | ".join(detail_errors[-4:])
                    + " || list_fallback_failed: "
                    + " | ".join(list_errors[-2:])
                )

            list_defaults = self._extract_hidden_inputs(list_html)
            token = list_defaults.get("wimToken", "")
            if not token:
                token = self._extract_wim_token(list_html)

            base_form: dict[str, str] = {
                "wimToken": token,
                "entryTypeIn": "1",
                "modeIn": "ADD",
                "open": "",
                "title": "",
            }
            if fields and isinstance(fields, dict):
                for k, v in fields.items():
                    key = str(k or "").strip()
                    if not key:
                        continue
                    base_form[key] = "" if v is None else str(v)

            # Some Ricoh models use different field names in set endpoint.
            field_variants: list[dict[str, str]] = [
                {
                    "nameIn": str(name or "").strip(),
                    "emailAddressIn": str(email or "").strip(),
                    "folderPathIn": str(folder or "").strip(),
                    "userCodeIn": str(user_code or "").strip(),
                },
                {
                    "userNameIn": str(name or "").strip(),
                    "emailIn": str(email or "").strip(),
                    "folderIn": str(folder or "").strip(),
                    "userCode": str(user_code or "").strip(),
                },
                {
                    "displayNameIn": str(name or "").strip(),
                    "mailAddressIn": str(email or "").strip(),
                    "pathIn": str(folder or "").strip(),
                    "codeIn": str(user_code or "").strip(),
                },
            ]
            referer_candidates = [
                f"http://{printer.ip}{list_url}",
                f"http://{printer.ip}/web/entry/en/address/adrsGetUserWizard.cgi?modeIn=ADD&entryTypeIn=1",
                f"http://{printer.ip}/web/entry/en/address/adrsGetUserWizard.cgi",
                f"http://{printer.ip}/web/guest/en/address/adrsGetUserWizard.cgi?modeIn=ADD&entryTypeIn=1",
                f"http://{printer.ip}/web/guest/en/address/adrsGetUserWizard.cgi",
            ]
            post_targets = [
                f"http://{printer.ip}{set_url}",
                f"http://{printer.ip}/web/guest/en/address/adrsSetUserWizard.cgi",
            ]

            attempt_errors: list[str] = []
            for post_url in post_targets:
                for referer in referer_candidates:
                    for variant in field_variants:
                        direct_form = dict(base_form)
                        direct_form.update(variant)
                        try:
                            resp = session.post(
                                post_url,
                                data=direct_form,
                                headers={"Referer": referer},
                                timeout=15,
                            )
                            text = resp.text or ""
                            if resp.status_code >= 400:
                                attempt_errors.append(
                                    f"status={resp.status_code} post={post_url} referer={referer} excerpt={text[:120]}"
                                )
                                continue
                            if "login.cgi" in text or "authForm.cgi" in text:
                                attempt_errors.append(f"login_redirect post={post_url} referer={referer}")
                                continue

                            verify_raw = ""
                            verify_entries: list[AddressEntry] = []
                            try:
                                verify_raw = self.get_address_list_ajax_with_client(session, printer)
                                verify_entries = self.parse_ajax_address_list(verify_raw)
                            except Exception:  # noqa: BLE001
                                verify_raw = ""
                                verify_entries = []

                            name_norm = str(name or "").strip().lower()
                            created = next(
                                (
                                    e
                                    for e in verify_entries
                                    if str(e.name or "").strip().lower() == name_norm
                                ),
                                None,
                            )

                            return {
                                "printer_name": printer.name,
                                "ip": printer.ip,
                                "ok": True,
                                "endpoint": post_url.replace(f"http://{printer.ip}", ""),
                                "name": str(name or "").strip(),
                                "http_status": resp.status_code,
                                "response_excerpt": text[:600],
                                "verify_count": len(verify_entries),
                                "created_registration_no": str(created.registration_no) if created else "",
                                "fallback_mode": "direct_set_from_list",
                                "timestamp": self._timestamp(),
                            }
                        except Exception as exc:  # noqa: BLE001
                            attempt_errors.append(
                                f"post={post_url} referer={referer} error={type(exc).__name__}:{exc}"
                            )
                            continue

            raise RuntimeError(
                "direct create fallback failed; "
                + " | ".join(attempt_errors[-8:])
                + " || detail_fallback_trace: "
                + " | ".join(detail_errors[-4:])
            )

        defaults = self._extract_hidden_inputs(html)
        token = defaults.get("wimToken", "")
        if not token:
            token = self._extract_wim_token(html)
        defaults["wimToken"] = token

        key_list = list(defaults.keys())
        name_key = self._pick_field_key(key_list, ["nameIn", "userNameIn", "displayNameIn", "name"])
        email_key = self._pick_field_key(key_list, ["emailAddressIn", "emailIn", "mailAddressIn", "email"])
        folder_key = self._pick_field_key(key_list, ["folderPathIn", "folderIn", "pathIn", "folder"])
        user_code_key = self._pick_field_key(key_list, ["userCodeIn", "userCode", "codeIn"])

        if name_key:
            defaults[name_key] = str(name or "").strip()
        else:
            defaults["nameIn"] = str(name or "").strip()
        if email:
            defaults[email_key or "emailAddressIn"] = str(email).strip()
        if folder:
            defaults[folder_key or "folderPathIn"] = str(folder).strip()
        if user_code:
            defaults[user_code_key or "userCodeIn"] = str(user_code).strip()

        if fields and isinstance(fields, dict):
            for k, v in fields.items():
                key = str(k or "").strip()
                if not key:
                    continue
                defaults[key] = "" if v is None else str(v)

        defaults.setdefault("open", "")

        referer = list_url or get_url or "/web/entry/en/address/adrsList.cgi?modeIn=LIST_ALL"
        resp = session.post(
            f"http://{printer.ip}{set_url}",
            data=defaults,
            headers={
                "Referer": f"http://{printer.ip}{referer}",
                "X-Requested-With": "XMLHttpRequest",
            },
            timeout=15,
        )
        self._append_address_debug(
            "address_modify:submit "
            f"ip={printer.ip} reg={reg} url={set_url} status={resp.status_code} "
            f"resp_excerpt={repr((resp.text or '')[:300])}"
        )
        resp.raise_for_status()

        verify_raw = ""
        verify_count = 0
        try:
            verify_raw = self.get_address_list_ajax_with_client(session, printer)
            parsed = self.parse_ajax_address_list(verify_raw)
            verify_count = len(parsed)
        except Exception:  # noqa: BLE001
            verify_raw = ""
            verify_count = 0

        return {
            "printer_name": printer.name,
            "ip": printer.ip,
            "ok": True,
            "endpoint": set_url,
            "name": str(name or "").strip(),
            "http_status": resp.status_code,
            "response_excerpt": resp.text[:600],
            "verify_count": verify_count,
            "timestamp": self._timestamp(),
        }

    def modify_address_user_wizard(
        self,
        printer: Printer,
        registration_no: str,
        name: str = "",
        email: str = "",
        folder: str = "",
        user_code: str = "",
        fields: dict[str, Any] | None = None,
    ) -> dict[str, Any]:
        reg = str(registration_no or "").strip()
        if not reg:
            raise ValueError("registration_no is required")

        session = self.create_http_client_auth_form_only(printer)
        set_url = "/web/entry/en/address/adrsSetUserWizard.cgi"
        warmup_targets = [
            "/web/entry/en/address/adrsList.cgi?modeIn=LIST_ALL",
            "/web/guest/en/address/adrsList.cgi?modeIn=LIST_ALL",
        ]
        list_html = ""
        list_url = ""
        for target in warmup_targets:
            try:
                candidate = self.authenticate_and_get(session, printer, target)
                if candidate.strip() and "login.cgi" not in candidate and "authForm.cgi" not in candidate:
                    list_html = candidate
                    list_url = target
                    break
            except Exception:  # noqa: BLE001
                continue
        list_defaults = self._extract_hidden_inputs(list_html) if list_html else {}
        list_token = str(list_defaults.get("wimToken", "")).strip()
        if not list_token and list_html:
            try:
                list_token = self._extract_wim_token(list_html)
            except Exception:  # noqa: BLE001
                list_token = ""

        get_candidates = [
            f"/web/entry/en/address/adrsGetUserWizard.cgi?regiNoIn={reg}&modeIn=MOD",
            f"/web/entry/en/address/adrsGetUserWizard.cgi?regiNoIn={reg}&modeIn=EDIT",
            f"/web/entry/en/address/adrsGetUserWizard.cgi?modeIn=MOD&regiNoIn={reg}",
            f"/web/entry/en/address/adrsGetUserWizard.cgi?modeIn=EDIT&regiNoIn={reg}",
            f"/web/entry/en/address/adrsGetUserWizard.cgi?regiNoIn={reg}",
            f"/web/guest/en/address/adrsGetUserWizard.cgi?regiNoIn={reg}&modeIn=MOD",
            f"/web/guest/en/address/adrsGetUserWizard.cgi?regiNoIn={reg}&modeIn=EDIT",
            f"/web/guest/en/address/adrsGetUserWizard.cgi?modeIn=MOD&regiNoIn={reg}",
            f"/web/guest/en/address/adrsGetUserWizard.cgi?modeIn=EDIT&regiNoIn={reg}",
            f"/web/guest/en/address/adrsGetUserWizard.cgi?regiNoIn={reg}",
        ]
        html = ""
        get_url = ""
        open_errors: list[str] = []
        for target in get_candidates:
            try:
                candidate_html = self.authenticate_and_get(session, printer, target)
                if not candidate_html.strip():
                    open_errors.append(f"{target}:empty")
                    continue
                if "login.cgi" in candidate_html or "authForm.cgi" in candidate_html:
                    open_errors.append(f"{target}:login_page")
                    continue
                html = candidate_html
                get_url = target
                break
            except Exception as exc:  # noqa: BLE001
                open_errors.append(f"{target}:{type(exc).__name__}:{exc}")
                if list_token:
                    try:
                        post_resp = session.post(
                            f"http://{printer.ip}{target}",
                            data={
                                "wimToken": list_token,
                                "regiNoIn": reg,
                                "modeIn": "MOD",
                                "mode": "EDITUSER",
                                "open": "",
                                "title": "",
                            },
                            headers={"Referer": f"http://{printer.ip}{list_url}"} if list_url else {},
                            timeout=15,
                        )
                        post_text = post_resp.text or ""
                        if post_resp.status_code < 400 and "login.cgi" not in post_text and "authForm.cgi" not in post_text and post_text.strip():
                            html = post_text
                            get_url = target
                            break
                        open_errors.append(f"{target}:post_status={post_resp.status_code}")
                    except Exception as post_exc:  # noqa: BLE001
                        open_errors.append(f"{target}:post_error={type(post_exc).__name__}:{post_exc}")
                continue
        if not html:
            raise RuntimeError("cannot open modify wizard; " + " | ".join(open_errors[-6:]))

        defaults = self._extract_hidden_inputs(html)
        token = defaults.get("wimToken", "")
        if not token:
            token = self._extract_wim_token(html)
        defaults["wimToken"] = token

        key_list = list(defaults.keys())
        reg_key = self._pick_field_key(key_list, ["regiNoIn", "registrationNoIn", "entryNoIn"])
        mode_key = self._pick_field_key(key_list, ["modeIn", "actionModeIn", "procModeIn"])
        name_key = self._pick_field_key(key_list, ["nameIn", "userNameIn", "displayNameIn", "name"])
        email_key = self._pick_field_key(key_list, ["emailAddressIn", "emailIn", "mailAddressIn", "email"])
        folder_key = self._pick_field_key(key_list, ["folderPathIn", "folderIn", "pathIn", "folder"])
        user_code_key = self._pick_field_key(key_list, ["userCodeIn", "userCode", "codeIn"])

        defaults[reg_key or "regiNoIn"] = reg
        defaults[mode_key or "modeIn"] = defaults.get(mode_key or "modeIn", "MOD")
        if name:
            defaults[name_key or "nameIn"] = str(name).strip()
        if email:
            defaults[email_key or "emailAddressIn"] = str(email).strip()
        if folder:
            defaults[folder_key or "folderPathIn"] = str(folder).strip()
        if user_code:
            defaults[user_code_key or "userCodeIn"] = str(user_code).strip()
        if fields and isinstance(fields, dict):
            for k, v in fields.items():
                key = str(k or "").strip()
                if not key:
                    continue
                defaults[key] = "" if v is None else str(v)

        defaults.setdefault("open", "")

        resp = session.post(
            f"http://{printer.ip}{set_url}",
            data=defaults,
            headers={"Referer": f"http://{printer.ip}{get_url}"},
            timeout=15,
        )
        resp.raise_for_status()

        verify_raw = self.get_address_list_ajax_with_client(session, printer)
        verify_entries = self.parse_ajax_address_list(verify_raw)
        updated = next((e for e in verify_entries if str(e.registration_no or "").strip() == reg), None)
        if updated is None:
            raise RuntimeError(f"Modified entry not found after set: registration_no={reg}")

        return {
            "printer_name": printer.name,
            "ip": printer.ip,
            "ok": True,
            "endpoint": set_url,
            "registration_no": reg,
            "name": updated.name,
            "email_address": updated.email_address,
            "folder": updated.folder,
            "user_code": updated.user_code,
            "http_status": resp.status_code,
            "timestamp": self._timestamp(),
        }

    def delete_address_entries(
        self,
        printer: Printer,
        registration_numbers: list[str],
        entry_ids: list[str] | None = None,
        verify: bool = True,
    ) -> dict[str, Any]:
        regs = [str(x or "").strip() for x in registration_numbers if str(x or "").strip()]
        ids = [str(x or "").strip() for x in (entry_ids or []) if str(x or "").strip()]
        if not regs and not ids:
            raise ValueError("registration_numbers is empty")

        session = self.create_http_client(printer)
        list_url = "/web/entry/en/address/adrsList.cgi?modeIn=LIST_ALL"
        delete_url = "/web/entry/en/address/adrsDeleteEntries.cgi"
        html = self.authenticate_and_get(session, printer, list_url)
        defaults = self._extract_hidden_inputs(html)
        token = defaults.get("wimToken", "")
        if not token:
            token = self._extract_wim_token(html)
        defaults["wimToken"] = token

        form: list[tuple[str, str]] = [(k, str(v)) for k, v in defaults.items()]
        if ids:
            joined = ",".join(ids)
            if joined and not joined.endswith(","):
                joined = f"{joined},"
            # Align with Ricoh JS: entryIndex list + wimToken only.
            form.append(("entryIndex", joined))
            form.append(("entryIndexIn", joined))
        else:
            joined = ",".join(regs)
            # Best-effort compatibility across Ricoh model variants.
            for key in (
                "regiNoListIn",
                "registrationNoListIn",
                "entryNoListIn",
                "selectedRegiNoIn",
                "selectedEntryNoIn",
                "deleteListIn",
                "deleteEntriesIn",
                "entryIndex",
                "entryIndexIn",
            ):
                form.append((key, joined))
                for reg in regs:
                    form.append((key, reg))
            form.append(("open", ""))

        # Use multipart form to mirror Ricoh JS delete flow.
        multipart = [(k, (None, str(v))) for k, v in form]
        resp = session.post(
            f"http://{printer.ip}{delete_url}",
            files=multipart,
            headers={"Referer": f"http://{printer.ip}{list_url}"},
            timeout=15,
        )
        resp.raise_for_status()

        if verify:
            verify_raw = self.get_address_list_ajax_with_client(session, printer)
            verify_entries = self.parse_ajax_address_list(verify_raw)
            if ids:
                remain = {str(getattr(e, "entry_id", "") or "").strip() for e in verify_entries}
                failed = [reg for reg in ids if reg in remain]
            else:
                remain = {str(e.registration_no or "").strip() for e in verify_entries}
                failed = [reg for reg in regs if reg in remain]
            if failed:
                label = "entry_id" if ids else "registration_no"
                raise RuntimeError(f"Delete not confirmed for {label}: {', '.join(failed)}")

        return {
            "printer_name": printer.name,
            "ip": printer.ip,
            "ok": True,
            "endpoint": delete_url,
            "deleted": ids or regs,
            "deleted_count": len(ids or regs),
            "http_status": resp.status_code,
            "timestamp": self._timestamp(),
        }

    def parse_address_list(self, html: str) -> list[AddressEntry]:
        user_count = re.search(r'<span id="span_numOfUsers">(\d+)</span>', html)
        group_count = re.search(r'<span id="span_numOfGroups">(\d+)</span>', html)
        user_code_count = re.search(r'<span id="span_numOfUserCode">(\d+)</span>', html)
        entries = [
            AddressEntry(
                type="Summary",
                registration_no="-",
                name=f"Users: {user_count.group(1) if user_count else '0'}, Groups: {group_count.group(1) if group_count else '0'}, User Codes: {user_code_count.group(1) if user_code_count else '0'}",
                user_code="-",
                date_last_used="-",
                email_address="-",
                folder="-",
            )
        ]

        tbody_match = re.search(r'<tbody id="ReportListArea_TableBody">(.*?)</tbody>', html, re.S)
        if not tbody_match:
            return entries

        rows = re.findall(r"<tr(?:\s+[^>]*)?>(?:\s*<td[^>]*>.*?</td>\s*){7,}</tr>", tbody_match.group(1), re.S)
        for row in rows:
            if "reportListDummyRow" in row:
                continue
            cells = re.findall(r"<td[^>]*>(.*?)</td>", row, re.S)
            if len(cells) < 8:
                continue
            entry = AddressEntry(
                type=self._strip_html(cells[1]),
                registration_no=self._strip_html(cells[2]),
                name=self._strip_html(cells[3]),
                user_code=self._strip_html(cells[4]),
                date_last_used=self._strip_html(cells[5]),
                email_address=self._strip_html(cells[6]),
                folder=self._strip_html(cells[7]),
            )
            if entry.name and entry.name != "-" and entry.registration_no:
                entries.append(entry)
        return entries

    def get_address_list_ajax_with_client(self, session: requests.Session, printer: Printer) -> str:
        targets = [
            "/web/entry/en/address/adrsListLoadEntry.cgi?listCountIn=200&getCountIn=1",
            "/web/entry/en/address/adrsListLoadEntry.cgi?listCountIn=50&getCountIn=1",
            "/web/guest/en/address/adrsListLoadEntry.cgi?listCountIn=200&getCountIn=1",
            "/web/guest/en/address/adrsListLoadEntry.cgi?listCountIn=50&getCountIn=1",
        ]
        last = ""
        for target in targets:
            try:
                raw = self.authenticate_and_get(session, printer, target)
                last = raw
                has_login_markers = "login.cgi" in raw or "Login User Name" in raw or "authForm.cgi" in raw
                if has_login_markers:
                    continue
                if "[" in raw and "]" in raw:
                    return raw
            except Exception:  # noqa: BLE001
                continue
        return last

    @staticmethod
    def parse_javascript_array_fields(data: str) -> list[str]:
        fields: list[str] = []
        current: list[str] = []
        in_quotes = False
        quote_char = ""
        escaped = False
        for char in data:
            if escaped:
                current.append(char)
                escaped = False
                continue
            if char == "\\":
                current.append(char)
                escaped = True
                continue
            if char in {"'", '"'}:
                if not in_quotes:
                    in_quotes = True
                    quote_char = char
                elif char == quote_char:
                    in_quotes = False
                else:
                    current.append(char)
                continue
            if char == "," and not in_quotes:
                fields.append("".join(current).strip())
                current = []
            else:
                current.append(char)
        if current:
            fields.append("".join(current).strip())
        return fields

    def parse_ajax_address_list(self, data: str) -> list[AddressEntry]:
        entries: list[AddressEntry] = []
        raw = str(data or "").strip()
        if not raw:
            return entries

        # Some Ricoh models wrap array payload in JS callbacks/vars.
        data = raw
        if not (data.startswith("[") and data.endswith("]")):
            first = data.find("[")
            last = data.rfind("]")
            if first < 0 or last <= first:
                return entries
            data = data[first : last + 1]

        # Keep existing parser behavior for entry chunks inside top-level array.
        raw_entries = re.findall(r"\[([^\]]+)\]", data)
        for raw in raw_entries:
            fields = self.parse_javascript_array_fields(raw)
            if len(fields) < 8:
                continue
            last_used = fields[5]
            if "#" in last_used:
                last_used = last_used.split("#", 1)[1]
            type_map = {"1": "User", "2": "Group"}
            raw_entry_id = fields[0].strip().lstrip("[").strip("'\"")
            entry = AddressEntry(
                type=type_map.get(fields[1], f"Type_{fields[1]}"),
                registration_no=fields[2].strip("'\""),
                name=fields[3].strip("'\""),
                user_code=fields[4].strip("'\""),
                date_last_used=last_used.strip("'\""),
                email_address=fields[6].strip("'\""),
                folder=fields[7].strip("'\""),
                entry_id=raw_entry_id,
            )
            if entry.name or entry.registration_no:
                entries.append(entry)
        return entries

    def process_address_list(self, printer: Printer, trace_id: str = "") -> dict[str, Any]:
        session = self.create_http_client(printer)
        easysecurity_html = ""
        try:
            easysecurity_html = self.authenticate_and_get(
                session, printer, "/web/entry/en/websys/webArch/mainFrame.cgi?open=websys/easySecurity/getEasySecurity.cgi"
            )
            if not str(easysecurity_html or "").strip():
                easysecurity_html = self.authenticate_and_get(
                    session, printer, "/web/entry/en/websys/easySecurity/getEasySecurity.cgi"
                )
            self._append_address_debug(
                f"address_list:easysecurity trace_id={trace_id or '-'} ip={printer.ip} easysecurity_len={len(easysecurity_html)} "
                f"easysecurity_excerpt={repr(easysecurity_html[:300])}"
            )
        except Exception as exc:  # noqa: BLE001
            self._append_address_debug(
                f"address_list:easysecurity_error trace_id={trace_id or '-'} ip={printer.ip} error={type(exc).__name__}:{str(exc)}"
            )
        html = self.read_address_list_with_client(session, printer)
        entries = self.parse_address_list(html)
        has_table = '<tbody id="ReportListArea_TableBody">' in html
        has_login_markers = "login.cgi" in html or "Login User Name" in html or "authForm.cgi" in html
        has_address_markers = "Address List" in html or "adrsList" in html
        non_summary_html_entries = max(0, len(entries) - 1)
        self._append_address_debug(
            "address_list:start "
            f"trace_id={trace_id or '-'} ip={printer.ip} name={printer.name} html_len={len(html)} "
            f"entries_html={len(entries)} non_summary_html_entries={non_summary_html_entries} "
            f"has_table={has_table} has_address_markers={has_address_markers} has_login_markers={has_login_markers}"
        )
        LOGGER.info(
            "Address list start: trace_id=%s ip=%s name=%s html_len=%s entries_html=%s non_summary_html_entries=%s has_table=%s has_address_markers=%s has_login_markers=%s",
            trace_id or "-",
            printer.ip,
            printer.name,
            len(html),
            len(entries),
            non_summary_html_entries,
            has_table,
            has_address_markers,
            has_login_markers,
        )
        ajax_raw = ""
        ajax_entries: list[AddressEntry] = []
        ajax_has_login_markers = False
        try:
            ajax_raw = self.get_address_list_ajax_with_client(session, printer)
            ajax_entries = self.parse_ajax_address_list(ajax_raw)
            ajax_has_brackets = "[" in ajax_raw and "]" in ajax_raw
            ajax_has_login_markers = "login.cgi" in ajax_raw or "Login User Name" in ajax_raw or "authForm.cgi" in ajax_raw
            self._append_address_debug(
                "address_list:ajax "
                f"trace_id={trace_id or '-'} ip={printer.ip} ajax_len={len(ajax_raw)} ajax_entries={len(ajax_entries)} "
                f"ajax_has_brackets={ajax_has_brackets} ajax_has_login_markers={ajax_has_login_markers} "
                f"ajax_excerpt={repr(ajax_raw[:300])}"
            )
            LOGGER.info(
                "Address list ajax: trace_id=%s ip=%s ajax_len=%s ajax_entries=%s ajax_has_brackets=%s ajax_has_login_markers=%s",
                trace_id or "-",
                printer.ip,
                len(ajax_raw),
                len(ajax_entries),
                ajax_has_brackets,
                ajax_has_login_markers,
            )
            if ajax_entries and entries:
                entries = [entries[0], *ajax_entries]
        except Exception as exc:  # noqa: BLE001
            self._append_address_debug(
                f"address_list:ajax_error trace_id={trace_id or '-'} ip={printer.ip} error={type(exc).__name__}:{str(exc)}"
            )
            LOGGER.exception("Address list ajax error: trace_id=%s ip=%s", trace_id or "-", printer.ip)
        if max(0, len(entries) - 1) == 0 and (has_login_markers or ajax_has_login_markers):
            reason = "html_login" if has_login_markers else "ajax_login"
            self._append_address_debug(
                f"address_list:auth_required trace_id={trace_id or '-'} ip={printer.ip} reason={reason}"
            )
            LOGGER.warning("Address list auth required: trace_id=%s ip=%s reason=%s", trace_id or "-", printer.ip, reason)
            raise RuntimeError("address list authentication required (login page detected)")
        if max(0, len(entries) - 1) == 0:
            reasons: list[str] = []
            if has_login_markers:
                reasons.append("html_contains_login_markers")
            if not has_table:
                reasons.append("html_missing_report_table")
            if not has_address_markers:
                reasons.append("html_missing_address_markers")
            if ajax_raw and len(ajax_entries) == 0:
                reasons.append("ajax_present_but_no_parsed_entries")
            if not ajax_raw:
                reasons.append("ajax_response_empty")
            if not reasons:
                reasons.append("no_entry_matched_filters")
            reason_text = ",".join(reasons)
            self._append_address_debug(
                f"address_list:no_data trace_id={trace_id or '-'} ip={printer.ip} reasons={reason_text}"
            )
            LOGGER.warning("Address list no data: trace_id=%s ip=%s reasons=%s", trace_id or "-", printer.ip, reason_text)
        self._append_address_debug(
            "address_list:final "
            f"trace_id={trace_id or '-'} ip={printer.ip} total_entries={len(entries)} "
            f"first_entries={repr([asdict(x) for x in entries[:3]])}"
        )
        LOGGER.info("Address list final: trace_id=%s ip=%s total_entries=%s", trace_id or "-", printer.ip, len(entries))
        payload = {
            "printer_name": printer.name,
            "ip": printer.ip,
            "html": html,
            "easysecurity_html": easysecurity_html,
            "address_list": [asdict(item) for item in entries],
            "debug": {
                "trace_id": trace_id,
                "easysecurity_len": len(easysecurity_html),
                "easysecurity_excerpt": easysecurity_html[:300],
                "html_len": len(html),
                "html_entries": len(self.parse_address_list(html)),
                "non_summary_html_entries": non_summary_html_entries,
                "html_has_table": has_table,
                "html_has_address_markers": has_address_markers,
                "html_has_login_markers": has_login_markers,
                "ajax_len": len(ajax_raw),
                "ajax_entries": len(ajax_entries),
                "ajax_excerpt": ajax_raw[:300],
                "debug_log_file": str(ADDRESS_DEBUG_LOG_FILE),
            },
            "timestamp": self._timestamp(),
        }
        return payload

    def start_counter_logging(self, printer: Printer) -> None:
        stop_event = threading.Event()

        def handle_signal(signum: int, _frame: Any) -> None:
            LOGGER.info("Received signal %s. Stopping counter logging.", signum)
            stop_event.set()

        old_int = signal.signal(signal.SIGINT, handle_signal)
        old_term = signal.signal(signal.SIGTERM, handle_signal)
        try:
            while not stop_event.is_set():
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                try:
                    data = self.parse_counter(self.read_counter(printer))
                    LOGGER.info("[%s] Counter summary: total=%s copier=%s printer=%s scanner=%s", timestamp, data.get("total", ""), data.get("copier_bw", ""), data.get("printer_bw", ""), data.get("scanner_send_bw", ""))
                except Exception as exc:  # noqa: BLE001
                    LOGGER.error("[%s] Counter logging failed: %s", timestamp, exc)
                stop_event.wait(60)
        finally:
            signal.signal(signal.SIGINT, old_int)
            signal.signal(signal.SIGTERM, old_term)

    @staticmethod
    def _prepare_csv_row(timestamp: str, printer: Printer, status_data: dict[str, str]) -> list[str]:
        def get_value(key: str) -> str:
            return status_data.get(key, "")

        other = [
            f"{k}:{v}"
            for k, v in status_data.items()
            if not any(token in k for token in ("system", "printer", "copier", "scanner", "toner", "tray"))
            and v
        ]
        return [
            timestamp,
            printer.name,
            printer.ip,
            get_value("system_status"),
            get_value("printer_status"),
            get_value("printer_alerts"),
            get_value("copier_status"),
            get_value("copier_alerts"),
            get_value("scanner_status"),
            get_value("scanner_alerts"),
            get_value("toner_black"),
            get_value("tray_1_status"),
            get_value("tray_2_status"),
            get_value("tray_3_status"),
            get_value("bypass_tray_status"),
            "; ".join(other),
        ]

    def start_status_logging(self, printer: Printer, csv_path: str | Path = "storage/data/log_status.csv") -> None:
        output = Path(csv_path)
        output.parent.mkdir(parents=True, exist_ok=True)
        write_header = not output.exists()
        with output.open("a", newline="", encoding="utf-8") as file:
            writer = csv.writer(file)
            if write_header:
                writer.writerow(
                    [
                        "timestamp",
                        "printer_name",
                        "printer_ip",
                        "system_status",
                        "printer_status",
                        "printer_alerts",
                        "copier_status",
                        "copier_alerts",
                        "scanner_status",
                        "scanner_alerts",
                        "toner_black",
                        "tray_1_status",
                        "tray_2_status",
                        "tray_3_status",
                        "bypass_tray_status",
                        "other_info",
                    ]
                )

            while True:
                timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                try:
                    status_data = self.parse_status(self.read_status(printer))
                    writer.writerow(self._prepare_csv_row(timestamp, printer, status_data))
                except Exception as exc:  # noqa: BLE001
                    writer.writerow(
                        [
                            timestamp,
                            printer.name,
                            printer.ip,
                            "ERROR",
                            "ERROR",
                            str(exc),
                            "ERROR",
                            "",
                            "ERROR",
                            "",
                            "ERROR",
                            "ERROR",
                            "ERROR",
                            "ERROR",
                            "ERROR",
                            "",
                        ]
                    )
                file.flush()
                time.sleep(30)
